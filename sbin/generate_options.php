#!/usr/bin/env php
<?php

/**
 * @copyright 2020 Anton Smirnov
 * @license MIT https://spdx.org/licenses/MIT.html
 */

declare(strict_types=1);

use Laminas\Code\DeclareStatement;
use Laminas\Code\Generator\ClassGenerator;
use Laminas\Code\Generator\DocBlock\Tag\GenericTag;
use Laminas\Code\Generator\DocBlockGenerator;
use Laminas\Code\Generator\FileGenerator;
use Laminas\Code\Generator\MethodGenerator;
use Laminas\Code\Generator\ParameterGenerator;
use Laminas\Code\Generator\PropertyGenerator;
use Laminas\Code\Generator\TypeGenerator;

use function Symfony\Component\String\s;

require __DIR__ . '/../vendor/autoload.php';

$config = [
    'DecodeOptions' => [
        'constants' => [
            'JSON_BIGINT_AS_STRING',
            'JSON_OBJECT_AS_ARRAY',
            'JSON_INVALID_UTF8_IGNORE',
            'JSON_INVALID_UTF8_SUBSTITUTE',
            'JSON_THROW_ON_ERROR',
        ],
        'builders' => [
            'default' => $decdef = 'JSON_THROW_ON_ERROR',
            'asArray' => $decdef . ' | JSON_OBJECT_AS_ARRAY',
        ],
    ],
    'EncodeOptions' => [
        'constants' => [
            'JSON_HEX_TAG',
            'JSON_HEX_AMP',
            'JSON_HEX_APOS',
            'JSON_HEX_QUOT',
            'JSON_FORCE_OBJECT',
            'JSON_NUMERIC_CHECK',
            'JSON_PRETTY_PRINT',
            'JSON_UNESCAPED_SLASHES',
            'JSON_UNESCAPED_UNICODE',
            'JSON_PARTIAL_OUTPUT_ON_ERROR',
            'JSON_PRESERVE_ZERO_FRACTION',
            'JSON_UNESCAPED_LINE_TERMINATORS',
            'JSON_INVALID_UTF8_IGNORE',
            'JSON_INVALID_UTF8_SUBSTITUTE',
            'JSON_THROW_ON_ERROR',
        ],
        'builders' => [
            'default' => $encdef = 'JSON_THROW_ON_ERROR | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE',
            'pretty' => $encdef . ' | JSON_PRETTY_PRINT',
        ],
    ],
    'ValidateOptions' => [
        'constants' => [
            'JSON_INVALID_UTF8_IGNORE',
        ],
        'builders' => [
            'default' => '0',
        ],
    ],
];

foreach ($config as $classname => $options) {
    $filename = __DIR__ . '/../src/' . $classname . '.php';

    $file = new FileGenerator();
    $file->setDeclares([DeclareStatement::strictTypes(1)]);
    $file->setDocBlock(new DocBlockGenerator(
        'This class is autogenerated by sbin/generate_options.php',
        null,
        [
            // Copyright
            new GenericTag('copyright', '2020 Anton Smirnov'),
            new GenericTag('license', 'MIT https://spdx.org/licenses/MIT.html'),

            // Suppress known inspection positives

            // PHPStorm:
            // doesn't matter in the autogenerated code
            new GenericTag('noinspection', 'DuplicatedCode'),
            // it's a library after all
            new GenericTag('noinspection', 'PhpUnused'),
        ],
    ));

    $class = new ClassGenerator($classname, 'Arokettu\\Json', ClassGenerator::FLAG_FINAL);
    $class->setDocBlock(new DocBlockGenerator(null, null, [
        new GenericTag('generated'),
        new GenericTag('immutable'),
    ]));

    $buildParamsSnake = [];
    $methods = [];

    foreach ($options['constants'] as $constant) {
        $snakeName = strtolower(substr($constant, 5));
        $camelName = s($snakeName)->camel()->toString();
        $pascalName = ucfirst($camelName);

        $buildParamsSnake[$snakeName] = $constant;

        $with = new MethodGenerator('with' . $pascalName);
        $with->setBody(<<<PHP
            return new self(\$this->options | {$constant});
            PHP);
        $with->setReturnType('self');

        $methods[] = $with;

        $without = new MethodGenerator('without' . $pascalName);
        $without->setBody(<<<PHP
            return new self(\$this->options & ~{$constant});
            PHP);
        $without->setReturnType('self');

        $methods[] = $without;
    }

    // build()

    $buildParams = $buildParamsSnake;

    $build = new MethodGenerator('build');
    $build->setStatic(true);
    $build->setReturnType('self');
    $build->setParameter(new ParameterGenerator('options', 'int', 0));
    $build->setParameters(array_map(static function (string $paramName) {
        return (new ParameterGenerator($paramName, 'bool|null'))->setDefaultValue(null);
    }, array_keys($buildParams)));

    $body = '';

    foreach ($buildParams as $p => $c) {
        $body .= <<<PHP
            if (\${$p} !== null) {
                \$options = \${$p} ?
                    \$options | {$c} :
                    \$options & ~{$c}; 
            }

            PHP;
    }

    $body .= 'return new self($options);';

    $build->setBody($body);

    $class->addMethodFromGenerator($build);

    // other named constructors

    foreach ($options['builders'] as $name => $value) {
        $builder = new MethodGenerator($name);
        $builder->setStatic(true);
        $builder->setReturnType('self');
        $builder->setBody("return new self({$value});");

        $class->addMethodFromGenerator($builder);
    }

    // __construct()

    $constructor = new MethodGenerator('__construct');
    $constructor->setParameter(new ParameterGenerator('options', 'int'));
    $constructor->setBody('$this->options = $options;');

    $class->addMethodFromGenerator($constructor);
    $class->addPropertyFromGenerator(
        (new PropertyGenerator(
            'options',
            null,
            PropertyGenerator::FLAG_PRIVATE,
            TypeGenerator::fromTypeString('int'),
        ))->omitDefaultValue(),
    );

    // value() & toInt()

    $getValue = new MethodGenerator('value');
    $getValue->setReturnType('int');
    $getValue->setBody('return $this->options;');

    $class->addMethodFromGenerator($getValue);

    $toInt = clone $getValue;
    $toInt->setName('toInt');

    $class->addMethodFromGenerator($toInt);

    // toString()

    $string = new MethodGenerator('toString');
    $string->setReturnType('string');

    $body = "\$constants = [];\n";

    foreach ($options['constants'] as $c) {
        $body .= <<<PHP
            if (\$this->options & {$c}) {
                \$constants[] = '{$c}';
            }

            PHP;
    }

    $body .= "return \$constants === [] ? '0' : \\implode(' | ', \$constants);";

    $string->setBody($body);

    $class->addMethodFromGenerator($string);

    // add with/without methods

    $class->addMethods($methods);

    $file->setClass($class);

    $php = $file->generate();
    // phpcs will format every parameter on its own line in builder
    $php = str_replace('build(int', "build(\nint", $php);
    // remove excess line breaks at the start of the class
    $php = str_replace("\n{\n\n", "\n{\n", $php);

    file_put_contents($filename, str_replace('\\self', 'self', $php));

    $d = escapeshellarg(__DIR__);
    $f = escapeshellarg($filename);

    // normalize formatting by PHPCS
    // phpcs:ignore PHPCS_SecurityAudit.BadFunctions.SystemExecFunctions.WarnSystemExec
    passthru("$d/../vendor/bin/phpcbf $f");
}
